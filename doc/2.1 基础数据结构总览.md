### 负责度考量

![常见数据结构复杂度](..\imgs\2-1-1 常见数据结构复杂度.png)

**说明：**

1. 上面的时间复杂度指该操作所有情况的平均值
2. Indexing 指基于下标访问， 类似数组 array[10]这种
3. 



### 存储考量

除了复杂度， 存储结构也是我们选择数据结构的重要考量。典型的比如数据库选择用B树做索引。

**几个事实**

+ 不同存储层次的访问速度相差巨大

  通常访问内存要花费50 ns, 而访问磁盘要花费10 ms，二者相差10^5数量级，就像1秒之于1天。

+ 通常数据传输时间占整个读取时间比例较小，所以读取1byte和4k对整个读取时间无太大影响，而且磁盘一般也会按页进行预读

  假如不考虑预读，磁盘传输速度为100 M/S, 则传输时间如下：
  $$
  \begin{equation}
  \begin{aligned}
  &100M/S = 100 K/ms \\
  &1 byte / 10^5 byte/ms = 0.00001 ms \\
  &4 k / 10^2 K/ms = 0.04ms
  \end{aligned}
  \end{equation}
  $$

+ 在4k对齐的磁盘上， 存储1byte要占居4kb的物理空间， 存储5kb要占居8kb的物理空间



### 支持考量

从开发效率和软件质量上讲， 推荐优先使用语言或项目自带的数据结构：

一方面选择现成的数据结构可以节约我们的开发时间， 

另一方面现成的数据结构稳定性会相对更好，另起灶炉写出的数据结构会存在各种bug隐患



### 区别

#### 静态数组和动态数组

静态数组是直接声明创建，在静态存储区，而动态数组则是通过申请相应的内存创建， 在堆区

性能上讲二者没太大区别

python的List就是通过动态数组实现

对于动态数组，频繁的变更大小会导致性能比较差，通常采用预留空间和逻辑删除来优化插入和删除操作





#### 数组和链表

数组的内存是集中的，可以更好的利用缓存， 

链表的内存是分散的，可以更换的利用内存碎片

数组的大小变更成本为O(n)， 而链表大小变更成本为O(1)



链表适用于插入和删除比较频繁，但是搜索少的场景,   比如：

+ 内核采用链表对进程进行管理

+ 散列表可以采用开链法的来解决冲突



#### BST和BBST

+ BST的缺点存在退化情况

+ BST优点1 不需要额外的空间存储平衡因子

+ BST优点2 不需要维护平衡因子和旋转，在不失衡的情况下，效率会高1个常数因子

  



#### AVL和红黑树

AVL树的平均高度为1.44 * log（N + 2）-0.33
红黑树的最坏情况高度为2.00 * log（N + 1）

通常认为AVL树是高度平衡的， 而红黑树相对宽松， AVL的平均高度会比红黑树更低， 所以AVL的查询效率会比红黑树高,  而红黑树相对宽松的平衡条件，使得其相比AVL更不容易失衡， 红黑树在插入操作和删除操作上效率会更高。

对于插入操作， AVL和红黑树需要旋转的节点都为O(1),

对于删除操作， AVL最多需要O(log n), 红黑树需要O(1)



在linux中，对于short类型的变量， 其地址为2的倍数， 即地址最低位为0， 而对于其它类型的变量，其地址为4的倍数，即地址最低2位为0。这个前提一定程度上影响了红黑树和AVL的节点结构， 早期llinux里的红黑树就利用了这一特性,将颜色存在地址最低位，在使用时通过位运算实时获取实际地址， 这在一定程度上减少了红黑树占用的空间。对于AVL树， 往往需要额外的空间存储节点高度， 似乎也可以利用地址存储高度差(未验证这种实现)。新版本的linux中也把颜色信息拿出来了， 建议不要使用地址最低位存信息的方法。



红黑树应用：

+ linux内核、java Treemap  、c++ STL



在批量插入顺序数据时， AVL比较平衡， 而RB则偏右

关于持久化？



#### BBST和B树

从逻辑上讲， B树和BBST是等价的， 但是从存储上来讲，二者是完全不一样的。

B树查询的IO次数少， 并不是因为其树的高度低，而是因为其节点内的元素在同一个页表中

